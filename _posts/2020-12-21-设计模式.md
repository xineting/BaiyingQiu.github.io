---
layout:     post
title:      设计模式
subtitle:    23种设计模式
date:       2020-12-21
author:     XT
header-img: img/post-bg-coffee.jpeg
catalog: 	 true
tags:
    - 面试
---


> JAVA设计模式

# 一、单例模式（singleton pattern）

## 1、概念

> 单例模式的定义就是确保某一个类只有一个实例，并且提供一个全局访问点。属于设计模式三大类中的创建型模式。

单例模式具有典型的三个特点：

- 只有一个实例。
- 自我实例化。
- 提供全局访问点。

其**UML**结构图非常简单，就只有一个类，如下图：

![](https://raw.githubusercontent.com/xineting/xineting.github.io/master/pic1/2.png)

优点：由于单例模式只生成了一个实例，所以能够节约系统资源，减少性能开销，提高系统效率，同时也能够严格控制客户对它的访问。

缺点：也正是因为系统中只有一个实例，这样就导致了单例类的职责过重，违背了“单一职责原则”，同时也没有抽象类，这样扩展起来有一定的困难。



## 2、实现

常见的单例模式实现方式有五种：

- 饿汉式
- 懒汉式
- 双重检测锁式
- 静态内部类式
- 枚举单例

### 2.1、饿汉式：

```java
package com.example;

public class singleton_test {
    private static singleton_test instance = new singleton_test();
    private singleton_test(){ }
    public static singleton_test getInstance() {
        return instance;
    }
}
```

**是否 Lazy 初始化：**是

**是否多线程安全：**否

**实现难度：**易

优点：没有加锁，执行效率会提高。
缺点：类加载时就初始化，浪费内存。
它基于 classloader 机制避免了多线程的同步问题，不过，instance 在类装载时就实例化，虽然导致类装载的原因有很多种，在单例模式中大多数都是调用 getInstance 方法， 但是也不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化 instance 显然没有达到 lazy loading 的效果。



### 2.2、懒汉式：

```java
package com.example;
public class singleto_test2 {
    private static singleto_test2 Instance=null;
    private singleto_test2(){}
    public static singleto_test2 getInstance() {
        if (Instance==null){
            Instance=new singleto_test2();
        }
        return Instance;
    }
}
```

**是否 Lazy 初始化：**是

**是否多线程安全：**否

**实现难度：**易

**描述：**这种方式是最基本的实现方式，这种实现最大的问题就是不支持多线程。因为没有加锁 synchronized，所以严格意义上它并不算单例模式。这种方式 lazy loading 很明显，不要求线程安全，在多线程不能正常工作。由于该模式是在**运行时加载对象**的，所以加载类比较快，但是对象的获取速度相对较慢，且线程不安全。如果想要线程安全的话可以加上`synchronized`关键字，但是这样会付出惨重的效率代价。

线程不安全测试

```java
//singleto_test2.java
package com.example;
public class singleto_test2 {
    private static singleto_test2 Instance = null;
    private singleto_test2() { }
    public static singleto_test2 getInstance()  {
        if (Instance==null) {
            try {
                Thread.sleep(50);
                Instance=new singleto_test2();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        return Instance;
    }
}
```

```java
//test.java
package com.example;
public class test {
    public static void main(String[] args)  {

        for (int i = 0; i < 30; i++) {
            Thread test = new Thread(new MyThread());
            test.start();
        }
    }
}
class MyThread extends Thread {
    @Override
    public void run() {
        singleto_test2 instance = singleto_test2.getInstance();
        System.out.println(instance);
    }
}
```

运行结果如图所示：

![](https://raw.githubusercontent.com/xineting/xineting.github.io/master/pic1/image-20201224152204374.png)

### 2.3、懒汉式，线程安全

```java
package com.example;
public class singleto_test2 {
    private static singleto_test2 Instance=null;
    private singleto_test2(){}
    public static synchronized singleto_test2 getInstance() {
        if (Instance==null){
            Instance=new singleto_test2();
        }
        return Instance;
    }
}
```

**是否 Lazy 初始化：**是

**是否多线程安全：**是

**实现难度：**易

**描述：**这种方式具备很好的 lazy loading，能够在多线程中很好的工作，但是，效率很低，99% 情况下不需要同步。
优点：第一次调用才初始化，避免内存浪费。
缺点：必须加锁 synchronized 才能保证单例，但加锁会影响效率。
getInstance() 的性能对应用程序不是很关键（该方法使用不太频繁）。



### 2.4、懒汉式（双重同步锁）:

```java
package com.example;

public class singleto_test2 {
    private static volatile singleto_test2 Instance = null;
    private singleto_test2() { }
    public static singleto_test2 getInstance()  {
        if (Instance==null) {
            synchronized(singleto_test2.class){
                if (Instance==null){
                    Instance=new singleto_test2();
                }
            }
        }
        return Instance;
    }
}
```

**是否 Lazy 初始化：**是

**是否多线程安全：**是

**实现难度：**较复杂

**描述：**这种方式采用双锁机制，安全且在多线程情况下能保持高性能。
getInstance() 的性能对应用程序很关键。



### 2.5、登记式/静态内部类

```java
package com.example;
public class singleton_test3 {
    private static class SingletonHolder {
        private static final singleton_test3 INSTANCE = new singleton_test3();
    }
    private singleton_test3 (){}
    public static final singleton_test3 getInstance() {
        return SingletonHolder.INSTANCE;
    }
}
```

**是否 Lazy 初始化：**是

**是否多线程安全：**是

**实现难度：**一般

**描述：**这种方式能达到双检锁方式一样的功效，但实现更简单。

对静态域使用延迟初始化，应使用这种方式而不是双检锁方式。这种方式只适用于静态域的情况，双检锁方式可在实例域需要延迟初始化时使用。
这种方式同样利用了 classloader 机制来保证初始化 instance 时只有一个线程，它跟第 1种方式不同的是：第 1 种方式只要 Singleton 类被装载了，那么 instance 就会被实例化（没有达到 lazy loading 效果），而这种方式是 Singleton 类被装载了，instance 不一定被初始化。因为 SingletonHolder 类没有被主动使用，只有通过显式调用 getInstance 方法时，才会显式装载 SingletonHolder 类，从而实例化 instance。想象一下，如果实例化 instance 很消耗资源，所以想让它延迟加载，另外一方面，又不希望在 Singleton 类加载时就实例化，因为不能确保 Singleton 类还可能在其他的地方被主动使用从而被加载，那么这个时候实例化 instance 显然是不合适的。这个时候，这种方式相比第 1 种方式就显得很合理。

### 2.6、enum

```java
package com.example;
public enum singleton_test4 {
    INSTANCE;
    public static singleton_test4 getInstance() {
        return INSTANCE;
    }
}

```

**是否 Lazy 初始化：**否

**是否多线程安全：**是

**实现难度：**易

**描述：**这种实现方式还没有被广泛采用，但这是实现单例模式的最佳方法。它更简洁，自动支持序列化机制，绝对防止多次实例化。
这种方式是 Effective Java 作者 Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还自动支持序列化机制，防止反序列化重新创建新的对象，绝对防止多次实例化。不过，由于 JDK1.5 之后才加入 enum 特性，用这种方式写不免让人感觉生疏，在实际工作中，也很少用。
不能通过 reflection attack 来调用私有构造方法。



## 3、场景

- 网站计数器。 
- 项目中用于读取配置文件的类。
- 数据库连接池。因为数据库连接池是一种数据库资源。
- Spring中，每个`Bean`默认都是单例的，这样便于Spring容器进行管理。
- Servlet中`Applicatio
- Windows中任务管理器，回收站。

## 4、深度研究序列化问题

修改第一个恶汉模式的代码如图所示

```java
package com.example;
import java.io.Serializable;
public class singleton_test implements Serializable {
    ...
}
```

测试代码

```java
package com.example;
import java.io.*;
public class test {
    public static void main(String[] args) throws IOException, ClassNotFoundException {
        singleton_test instance = singleton_test.getInstance();
        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("text.txt"));
        oos.writeObject(instance);
        File file = new File("text.txt");
        FileInputStream fis = new FileInputStream(file);
        ObjectInputStream ois = new ObjectInputStream(fis);
        singleton_test newInstance = (singleton_test) ois.readObject();
        System.out.println(instance);
        System.out.println(newInstance);
    }
}
```

结果如图所示：

![image-20201224201014147](https://raw.githubusercontent.com/xineting/xineting.github.io/master/pic1/image-20201224201014147-8824292-8824388.png)

反序列化的结果显示与原对象不同

我们进入源码查看

![image-20201224220057194](https://raw.githubusercontent.com/xineting/xineting.github.io/master/pic1/image-20201224220057194-8824399.png)

可以看到最后读取的时候是new了一个对象出来

同时enum可以完美的解决这个问题。

```java
package com.example;


import java.io.*;

public enum singleton_test4 {
    INSTANCE;
    public static singleton_test4 getInstance() {
        return INSTANCE;
    }
    public static void main(String[] args) throws IOException, ClassNotFoundException {
        singleton_test4 instance = singleton_test4.getInstance();
        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("text.txt"));
        oos.writeObject(instance);
        File file = new File("text.txt");
        FileInputStream fis = new FileInputStream(file);
        ObjectInputStream ois = new ObjectInputStream(fis);
        singleton_test4 newInstance = (singleton_test4) ois.readObject();
        System.out.println(instance.hashCode());
        System.out.println(newInstance.hashCode());
    }
}

```

结果输出为

```java
/Library/Java/JavaVirtualMachines/jdk1.8.0_192.jdk/Contents/Home/bin/java -javaagent:/Appl...
1360875712
1360875712

Process finished with exit code 0
```



## 5、深度研究反射问题

```java
package com.example;

import java.io.*;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;

public class test {
    public static void main(String[] args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {
        singleton_test s=singleton_test.getInstance();
        singleton_test sUsual=singleton_test.getInstance();
        Constructor<singleton_test> constructor=singleton_test.class.getDeclaredConstructor();
        constructor.setAccessible(true);
        singleton_test sReflection=constructor.newInstance();
        System.out.println(s+"\n"+sUsual+"\n"+sReflection);
        System.out.println("正常情况下，实例化两个实例是否相同："+(s==sUsual));
        System.out.println("通过反射攻击单例模式情况下，实例化两个实例是否相同："+(s==sReflection));
    }
}
```



![image-20201224222856536](https://raw.githubusercontent.com/xineting/xineting.github.io/master/pic1/image-20201224222856536-8825185.png)

使用枚举的示例构造

![image-20201224223241655](https://raw.githubusercontent.com/xineting/xineting.github.io/master/pic1/image-20201224223241655-8825191.png)

发生了报错

![image-20201224225227648](https://raw.githubusercontent.com/xineting/xineting.github.io/master/pic1/image-20201224225227648-8824410.png)

原因是Enum并没有无参构造

```java
public abstract class Enum<E extends Enum<E>>
        implements Comparable<E>, Serializable {
        private final String name;
        public final String name() {
            return name;
        }
        private final int ordinal;
        public final int ordinal() {
            return ordinal;
        }
        protected Enum(String name, int ordinal) {
            this.name = name;
            this.ordinal = ordinal;
        }
        ...
```



我们构造父类构造器

```java
package com.example;

import java.io.*;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;

public class test {
    public static void main(String[] args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException {
        singleton_test4 s=singleton_test4.getInstance();
        singleton_test4 sUsual=singleton_test4.getInstance();
//        Constructor<singleton_test4> constructor=singleton_test4.class.getDeclaredConstructor();
        Constructor<singleton_test4> constructor= null;
        constructor = singleton_test4.class.getDeclaredConstructor(String.class,int.class);//其父类的构造器
        constructor.setAccessible(true);
        singleton_test4 sReflection=constructor.newInstance();
        System.out.println(s+"\n"+sUsual+"\n"+sReflection);
        System.out.println("正常情况下，实例化两个实例是否相同："+(s==sUsual));
        System.out.println("通过反射攻击单例模式情况下，实例化两个实例是否相同："+(s==sReflection));
    }
}
```

依旧发生了报错

![image-20201224225648350](https://raw.githubusercontent.com/xineting/xineting.github.io/master/pic1/image-20201224225648350-8824553.png)



请看黄颜色标注的第12行源码，说明反射在通过newInstance创建对象时，会检查该类是否ENUM修饰，如果是则抛出异常，反射失败。

![image-20201224230318973](https://raw.githubusercontent.com/xineting/xineting.github.io/master/pic1/image-20201224230318973-8824418.png)



# 二、工厂模式（Factory pattern)



## 1、概念

Java 中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。

在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。

**意图：**定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。

**主要解决：**主要解决接口选择的问题。

**优点：** 

- 一个调用者想创建一个对象，只要知道其名称就可以了。
- 2、扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 
- 3、屏蔽产品的具体实现，调用者只关心产品的接口。

**缺点：**每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。

**使用场景：** 

- 1、日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。
- 2、数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。 
- 3、设计一个连接服务器的框架，需要三个协议，"POP3"、"IMAP"、"HTTP"，可以把这三个作为产品类，共同实现一个接口。

**注意事项：**作为一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式。有一点需要注意的地方就是复杂对象适合使用工厂模式，而简单对象，特别是只需要通过 new 就可以完成创建的对象，无需使用工厂模式。如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度。



## 2、实现

我们将创建一个 *Shape* 接口和实现 *Shape* 接口的实体类。

下一步是定义工厂类 *ShapeFactory*。

*FactoryPatternDemo* 类使用 *ShapeFactory* 来获取 *Shape* 对象。它将向 *ShapeFactory* 传递信息（*CIRCLE / RECTANGLE / SQUARE*），以便获取它所需对象的类型。

![image-20201225011132660](/Users/wzx/Downloads/xineting.github.io/pic1/image-20201225011132660.png)

定义一个接口

```java
//Shape.java
public interface Shape {
   void draw();
}
```

定义实现接口的实体类

```java
public class Rectangle implements Shape {
   @Override
   public void draw() {
      System.out.println("Inside Rectangle::draw() method.");
   }
}
```

```java
public class Square implements Shape {
 
   @Override
   public void draw() {
      System.out.println("Inside Square::draw() method.");
   }
}
```

```java
public class Circle implements Shape {
 
   @Override
   public void draw() {
      System.out.println("Inside Circle::draw() method.");
   }
}
```

创建一个工厂

```java
//ShapeFactory.java
public class ShapeFactory {
   //使用 getShape 方法获取形状类型的对象
   public Shape getShape(String shapeType){
      if(shapeType == null){
         return null;
      }        
      if(shapeType.equalsIgnoreCase("CIRCLE")){
         return new Circle();
      } else if(shapeType.equalsIgnoreCase("RECTANGLE")){
         return new Rectangle();
      } else if(shapeType.equalsIgnoreCase("SQUARE")){
         return new Square();
      }
      return null;
   }
}
```

通过该工厂，获取实体对象

```java
public class FactoryPatternDemo {
 
   public static void main(String[] args) {
      ShapeFactory shapeFactory = new ShapeFactory();
 
      //获取 Circle 的对象，并调用它的 draw 方法
      Shape shape1 = shapeFactory.getShape("CIRCLE");
 
      //调用 Circle 的 draw 方法
      shape1.draw();
 
      //获取 Rectangle 的对象，并调用它的 draw 方法
      Shape shape2 = shapeFactory.getShape("RECTANGLE");
 
      //调用 Rectangle 的 draw 方法
      shape2.draw();
 
      //获取 Square 的对象，并调用它的 draw 方法
      Shape shape3 = shapeFactory.getShape("SQUARE");
 
      //调用 Square 的 draw 方法
      shape3.draw();
   }
}
```

结果输出

```java
Inside Circle::draw() method.
Inside Rectangle::draw() method.
Inside Square::draw() method.
```

# 三、抽象工厂模式

> 抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。

## 1、概念

**意图：**提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。

**主要解决：**主要解决接口选择的问题。

**何时使用：**系统的产品有多于一个的产品族，而系统只消费其中某一族的产品。

**如何解决：**在一个产品族里面，定义多个产品。

**关键代码：**在一个工厂里聚合多个同类产品。

**优点：**当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。

**缺点：**产品族扩展非常困难，要增加一个系列的某一产品，既要在抽象的 Creator 里加代码，又要在具体的里面加代码。

**使用场景：** 1、QQ 换皮肤，一整套一起换。 2、生成不同操作系统的程序。

**注意事项：**产品族难扩展，产品等级易扩展。

## 2、实现

![image-20201225011918989](/Users/wzx/Downloads/xineting.github.io/pic1/image-20201225011918989.png)

定义2个接口

```java
//Shape.java
public interface Shape {
   void draw();
}
```

```java
//Color.java
public interface Color {
   void fill();
}
```

定义实现接口的实体类

```java
public class Rectangle implements Shape {
   @Override
   public void draw() {
      System.out.println("Inside Rectangle::draw() method.");
   }
}
```

```java
public class Square implements Shape {
 
   @Override
   public void draw() {
      System.out.println("Inside Square::draw() method.");
   }
}
```

```java
public class Circle implements Shape {
 
   @Override
   public void draw() {
      System.out.println("Inside Circle::draw() method.");
   }
}
```

```java
//Red.java
public class Red implements Color {
 
   @Override
   public void fill() {
      System.out.println("Inside Red::fill() method.");
   }
}
```

```java
//Green.java
public class Green implements Color {
 
   @Override
   public void fill() {
      System.out.println("Inside Green::fill() method.");
   }
}
```

```java
//Blue.java
public class Blue implements Color {
 
   @Override
   public void fill() {
      System.out.println("Inside Blue::fill() method.");
   }
}
```

创建抽象工厂

```java
public abstract class AbstractFactory {
   public abstract Color getColor(String color);
   public abstract Shape getShape(String shape) ;
}
```

创建扩展了 AbstractFactory 的工厂类，基于给定的信息生成实体类的对象。

```java
//ShapeFactory.java
public class ShapeFactory extends AbstractFactory {
    
   @Override
   public Shape getShape(String shapeType){
      if(shapeType == null){
         return null;
      }        
      if(shapeType.equalsIgnoreCase("CIRCLE")){
         return new Circle();
      } else if(shapeType.equalsIgnoreCase("RECTANGLE")){
         return new Rectangle();
      } else if(shapeType.equalsIgnoreCase("SQUARE")){
         return new Square();
      }
      return null;
   }
   
   @Override
   public Color getColor(String color) {
      return null;
   }
}

```

```java
//ColorFactory.java
public class ColorFactory extends AbstractFactory {
    
   @Override
   public Shape getShape(String shapeType){
      return null;
   }
   
   @Override
   public Color getColor(String color) {
      if(color == null){
         return null;
      }        
      if(color.equalsIgnoreCase("RED")){
         return new Red();
      } else if(color.equalsIgnoreCase("GREEN")){
         return new Green();
      } else if(color.equalsIgnoreCase("BLUE")){
         return new Blue();
      }
      return null;
   }
}
```

创建一个工厂创造类,通过传递形状或颜色信息来获取工厂。

```java
//FactoryProducer.java
public class FactoryProducer {
   public static AbstractFactory getFactory(String choice){
      if(choice.equalsIgnoreCase("SHAPE")){
         return new ShapeFactory();
      } else if(choice.equalsIgnoreCase("COLOR")){
         return new ColorFactory();
      }
      return null;
   }
}
```

测试

```java
//AbstractFactoryPatternDemo.java
public class AbstractFactoryPatternDemo {
   public static void main(String[] args) {
 
      //获取形状工厂
      AbstractFactory shapeFactory = FactoryProducer.getFactory("SHAPE");
 
      //获取形状为 Circle 的对象
      Shape shape1 = shapeFactory.getShape("CIRCLE");
 
      //调用 Circle 的 draw 方法
      shape1.draw();
 
      //获取形状为 Rectangle 的对象
      Shape shape2 = shapeFactory.getShape("RECTANGLE");
 
      //调用 Rectangle 的 draw 方法
      shape2.draw();
      
      //获取形状为 Square 的对象
      Shape shape3 = shapeFactory.getShape("SQUARE");
 
      //调用 Square 的 draw 方法
      shape3.draw();
 
      //获取颜色工厂
      AbstractFactory colorFactory = FactoryProducer.getFactory("COLOR");
 
      //获取颜色为 Red 的对象
      Color color1 = colorFactory.getColor("RED");
 
      //调用 Red 的 fill 方法
      color1.fill();
 
      //获取颜色为 Green 的对象
      Color color2 = colorFactory.getColor("Green");
 
      //调用 Green 的 fill 方法
      color2.fill();
 
      //获取颜色为 Blue 的对象
      Color color3 = colorFactory.getColor("BLUE");
 
      //调用 Blue 的 fill 方法
      color3.fill();
   }
}
```

```java
Inside Circle::draw() method.
Inside Rectangle::draw() method.
Inside Square::draw() method.
Inside Red::fill() method.
Inside Green::fill() method.
Inside Blue::fill() method.
```

# 四、建造者模式

## 1、概念

>  使用多个简单的对象一步一步构造一个复杂的对象。这种类型属于创建型模式

**应用实例:**

- 去肯德基，汉堡、可乐、薯条、炸鸡翅等是不变的，而其组合是经常变化的，生成出所谓的"套餐"。 
- JAVA 中的 StringBuilder。

**优点：**

- 建造者独立，易扩展。 
- 便于控制细节风险。

**缺点：** 

- 产品必须有共同点，范围有限制。 
- 如内部变化复杂，会有很多的建造类。

**使用场景：** 

- 需要生成的对象具有复杂的内部结构。 
- 需要生成的对象内部属性本身相互依赖。

**注意事项：**与工厂模式的区别是：建造者模式更加关注与零件装配的顺序。



## 2、实现

我们假设一个快餐店的商业案例，其中，一个典型的套餐可以是一个汉堡（Burger）和一杯冷饮（Cold drink）。汉堡（Burger）可以是素食汉堡（Veg Burger）或鸡肉汉堡（Chicken Burger），它们是包在纸盒中。冷饮（Cold drink）可以是可口可乐（coke）或百事可乐（pepsi），它们是装在瓶子中。

我们将创建一个表示食物条目（比如汉堡和冷饮）的 *Item* 接口和实现 *Item* 接口的实体类，以及一个表示食物包装的 *Packing* 接口和实现 *Packing* 接口的实体类，汉堡是包在纸盒中，冷饮是装在瓶子中。

然后我们创建一个 *Meal* 类，带有 *Item* 的 *ArrayList* 和一个通过结合 *Item* 来创建不同类型的 *Meal* 对象的 *MealBuilder*。*BuilderPatternDemo* 类使用 *MealBuilder* 来创建一个 *Meal*。

![image-20201225122744763](/Users/wzx/Downloads/xineting.github.io/pic1/image-20201225122744763.png)

定义一个食物的item接口以及包装packing接口

```java
//Item.java
public interface Item {
   public String name();
   public Packing packing();
   public float price();    
}
```

```java
//Packing.java
public interface Packing {
   public String pack();
}
```

实现接口的类

```java
public class Wrapper implements Packing {
   @Override
   public String pack() {
      return "Wrapper";
   }
}
```

```java
public class Bottle implements Packing {
 
   @Override
   public String pack() {
      return "Bottle";
   }
}
```

创建实现ITEM的抽象类

```java
public abstract class Burger implements Item {
 
   @Override
   public Packing packing() {
      return new Wrapper();
   }
 
   @Override
   public abstract float price();
}
```

```java
public abstract class ColdDrink implements Item {
 
    @Override
    public Packing packing() {
       return new Bottle();
    }
 
    @Override
    public abstract float price();
}
```

创建实体类

```java
public class VegBurger extends Burger {
 
   @Override
   public float price() {
      return 25.0f;
   }
 
   @Override
   public String name() {
      return "Veg Burger";
   }
}
```

```java
//ChickenBurger.java
public class ChickenBurger extends Burger {
 
   @Override
   public float price() {
      return 50.5f;
   }
 
   @Override
   public String name() {
      return "Chicken Burger";
   }
}
```

```java
//Coke.java
public class Coke extends ColdDrink {
 
   @Override
   public float price() {
      return 30.0f;
   }
 
   @Override
   public String name() {
      return "Coke";
   }
}
```

```java
//Pepsi.java
public class Pepsi extends ColdDrink {
 
   @Override
   public float price() {
      return 35.0f;
   }
 
   @Override
   public String name() {
      return "Pepsi";
   }
}
```

创建一个 Meal 类，带有上面定义的 Item 对象。

```java
//Meal.java
import java.util.ArrayList;
import java.util.List;
 
public class Meal {
   private List<Item> items = new ArrayList<Item>();    
 
   public void addItem(Item item){
      items.add(item);
   }
 
   public float getCost(){
      float cost = 0.0f;
      for (Item item : items) {
         cost += item.price();
      }        
      return cost;
   }
 
   public void showItems(){
      for (Item item : items) {
         System.out.print("Item : "+item.name());
         System.out.print(", Packing : "+item.packing().pack());
         System.out.println(", Price : "+item.price());
      }        
   }    
}
```

创建一个 MealBuilder 类，实际的 builder 类负责创建 Meal 对象。

```java
public class MealBuilder {
 
   public Meal prepareVegMeal (){
      Meal meal = new Meal();
      meal.addItem(new VegBurger());
      meal.addItem(new Coke());
      return meal;
   }   
 
   public Meal prepareNonVegMeal (){
      Meal meal = new Meal();
      meal.addItem(new ChickenBurger());
      meal.addItem(new Pepsi());
      return meal;
   }
}
```

构造测试

```java
public class BuilderPatternDemo {
   public static void main(String[] args) {
      MealBuilder mealBuilder = new MealBuilder();
 
      Meal vegMeal = mealBuilder.prepareVegMeal();
      System.out.println("Veg Meal");
      vegMeal.showItems();
      System.out.println("Total Cost: " +vegMeal.getCost());
 
      Meal nonVegMeal = mealBuilder.prepareNonVegMeal();
      System.out.println("\n\nNon-Veg Meal");
      nonVegMeal.showItems();
      System.out.println("Total Cost: " +nonVegMeal.getCost());
   }
}
```

输出

```java
Veg Meal
Item : Veg Burger, Packing : Wrapper, Price : 25.0
Item : Coke, Packing : Bottle, Price : 30.0
Total Cost: 55.0


Non-Veg Meal
Item : Chicken Burger, Packing : Wrapper, Price : 50.5
Item : Pepsi, Packing : Bottle, Price : 35.0
Total Cost: 85.5
```

